import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/models/schedule_template.dart';
import '/core/models/session.dart';
import '/core/providers/client_providers.dart';
import '/core/providers/employee_providers.dart';
import '/core/providers/schedule_template_providers.dart';
import '/core/providers/time_slot_providers.dart';
import '/services/firebase_service.dart';
import '../data/repositories/session_repository_impl.dart';
import '../domain/repositories/session_repository.dart';

class SelectedDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  void setDate(DateTime newDate) {
    state = DateTime(newDate.year, newDate.month, newDate.day);
  }
}

final selectedDateProvider = NotifierProvider<SelectedDateNotifier, DateTime>(
  () {
    return SelectedDateNotifier();
  },
);

class ScheduleFilter {
  final String? clientId;
  final String? employeeId;

  const ScheduleFilter({this.clientId, this.employeeId});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScheduleFilter &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          employeeId == other.employeeId;

  @override
  int get hashCode => clientId.hashCode ^ employeeId.hashCode;
}

class ScheduleFilterNotifier extends Notifier<ScheduleFilter> {
  @override
  ScheduleFilter build() => const ScheduleFilter();

  void setFilter(ScheduleFilter filter) => state = filter;
  void clear() => state = const ScheduleFilter();
}

final scheduleFilterProvider =
    NotifierProvider<ScheduleFilterNotifier, ScheduleFilter>(
      ScheduleFilterNotifier.new,
    );

final sessionRepositoryProvider = Provider<ISessionRepository>((ref) {
  return SessionRepositoryImpl(ref.watch(firestoreProvider));
});

class ScheduleView {
  final List<dynamic> timeSlots;
  final Map<String, List<SessionCardData>> sessionsByTimeSlot;

  ScheduleView({required this.timeSlots, required this.sessionsByTimeSlot});
}

class SessionCardData {
  final String? sessionId;
  final String clientDocId; // Document ID
  final String clientId; // Sequential ID (e.g., 1)
  final String clientName;
  final String? clientNickName;
  final SessionStatus status;
  final List<ServiceDetail> services;
  final String? notes;
  final String? templateEmployeeId;
  final bool isAutoGenerated;
  final Map<String, String> employeeNames; // employeeId -> name/nickName

  SessionCardData({
    this.sessionId,
    required this.clientDocId,
    required this.clientId,
    required this.clientName,
    this.clientNickName,
    required this.status,
    required this.services,
    this.notes,
    this.templateEmployeeId,
    this.isAutoGenerated = false,
    this.employeeNames = const {},
  });

  /// Used for Weekly/Monthly views: Nickname(ID)
  String get displayNickName =>
      '${(clientNickName != null && clientNickName!.isNotEmpty) ? clientNickName : clientName}($clientId)';

  /// Used for Daily view: FullName(ID)
  String get displayFullName => '$clientName($clientId)';

  double get totalDuration =>
      services.fold(0.0, (sum, item) => sum + item.duration);

  String get servicesDisplay =>
      '[${services.map((s) => s.toString()).join(', ')}]';

  // Helpers for DailyView
  String get serviceNames => services.map((s) => s.type).join('\n');
  String get therapists => services
      .map((s) {
        final name = employeeNames[s.employeeId];
        return name ?? '-';
      })
      .join('\n');
  String get hours =>
      services.map((s) => '${s.startTime}-${s.endTime}').join('\n');
  String get durations =>
      services.map((s) => '${s.duration.toStringAsFixed(1)}h').join('\n');
  String get inclusiveStatus =>
      services.map((s) => s.isInclusive ? 'Inclusive' : 'Exclusive').join('\n');
  String get typeDisplay =>
      services.map((s) => s.sessionType.displayName).toSet().join('\n');

  String get id => sessionId ?? '';
}

final scheduleByDateProvider = FutureProvider.autoDispose
    .family<ScheduleView, DateTime>((ref, date) async {
      final filter = ref.watch(scheduleFilterProvider);
      final timeSlots = await ref.watch(timeSlotsProvider.future);
      final clients = await ref.watch(clientsProvider.future);
      final employees = await ref.watch(employeesProvider.future);

      // We only show real instances from the schedule collection
      final sessions = await ref
          .watch(sessionRepositoryProvider)
          .getSessionsByDate(date);

      final clientMap = {for (var c in clients) c.id: c};
      final employeeMap = {for (var t in employees) t.id: t};

      final sessionsByTimeSlot = <String, List<SessionCardData>>{};

      for (final session in sessions) {
        if (filter.clientId != null && session.clientId != filter.clientId) {
          continue;
        }

        if (filter.employeeId != null &&
            !session.services.any((s) => s.employeeId == filter.employeeId)) {
          continue;
        }

        final client = clientMap[session.clientId];

        if (client != null) {
          final names = <String, String>{};
          for (final s in session.services) {
            final emp = employeeMap[s.employeeId];
            if (emp != null) {
              names[s.employeeId] = emp.nickName.isNotEmpty
                  ? emp.nickName
                  : emp.name;
            }
          }

          final card = SessionCardData(
            sessionId: session.id,
            clientDocId: client.id,
            clientId: client.clientId,
            clientNickName: client.nickName,
            clientName: client.name,
            status: session.status,
            services: session.services,
            notes: session.notes,
            isAutoGenerated: session.isAutoGenerated,
            employeeNames: names,
          );

          sessionsByTimeSlot
              .putIfAbsent(session.timeSlotId, () => [])
              .add(card);
        }
      }
      return ScheduleView(
        timeSlots: timeSlots,
        sessionsByTimeSlot: sessionsByTimeSlot,
      );
    });

final scheduleViewProvider = FutureProvider.autoDispose<ScheduleView>((
  ref,
) async {
  final selectedDate = ref.watch(selectedDateProvider);
  return ref.watch(scheduleByDateProvider(selectedDate).future);
});

final sessionServiceProvider = Provider((ref) => SessionActionService(ref));

class SessionActionService {
  final Ref _ref;
  SessionActionService(this._ref);

  String _getDeterministicId(
    DateTime date,
    String clientId,
    String timeSlotId,
  ) {
    final dateStr = DateFormat('yyyy-MM-dd').format(date);
    return '${dateStr}_${clientId}_$timeSlotId';
  }

  Future<void> bookSession({
    required String clientId,
    required String timeSlotId,
    required SessionStatus status,
    required List<ServiceDetail> services,
    required DateTime date,
    bool isAutoGenerated = false,
    bool isRecurring = false,
    RecurrenceFrequency frequency = RecurrenceFrequency.none,
    int interval = 1,
    List<String> daysOfWeek = const [],
    required RecurrenceEndType endType,
    DateTime? untilDate,
    int? occurrences,
  }) async {
    final firestore = _ref.read(firestoreProvider);
    WriteBatch batch = firestore.batch();
    int opCount = 0;

    // 1. If recurring, setup the Template Rule first
    if (isRecurring && frequency != RecurrenceFrequency.none) {
      for (final service in services) {
        await _ref
            .read(scheduleTemplateServiceProvider)
            .setScheduleRule(
              clientId: clientId,
              timeSlotId: timeSlotId,
              employeeId: service.employeeId,
              serviceType: service.type,
              startTime: service.startTime,
              endTime: service.endTime,
              frequency: frequency,
              interval: interval,
              daysOfWeek: daysOfWeek,
              endType: endType,
              untilDate: untilDate,
              occurrences: occurrences,
              dayOfMonth: frequency == RecurrenceFrequency.monthly
                  ? date.day
                  : null,
              startDate: date,
            );
      }

      // 2. Generate all actual session instances immediately for Firestore
      DateTime current = DateTime(date.year, date.month, date.day);
      DateTime endLimit =
          untilDate ?? DateTime(date.year, date.month + 6, date.day);
      int createdCount = 0;

      while (true) {
        if (endType == RecurrenceEndType.onDate && current.isAfter(endLimit))
          break;
        if (endType == RecurrenceEndType.afterOccurrences &&
            createdCount >= (occurrences ?? 1))
          break;
        if (current.isAfter(date.add(const Duration(days: 730))))
          break; // 2 years limit

        final dayName = DateFormat('EEEE').format(current);
        bool shouldCreate = false;

        if (frequency == RecurrenceFrequency.daily) {
          shouldCreate = true;
        } else if (frequency == RecurrenceFrequency.weekly) {
          if (daysOfWeek.contains(dayName)) shouldCreate = true;
        } else if (frequency == RecurrenceFrequency.monthly) {
          if (current.day == date.day) shouldCreate = true;
        }

        if (shouldCreate) {
          final id = _getDeterministicId(current, clientId, timeSlotId);
          final docRef = firestore.collection('schedule').doc(id);

          final session = Session(
            id: id,
            clientId: clientId,
            timeSlotId: timeSlotId,
            date: Timestamp.fromDate(current),
            status: status,
            services: services,
            isAutoGenerated: true,
            createdAt: Timestamp.now(),
          );

          batch.set(docRef, session.toJson(), SetOptions(merge: true));
          opCount++;
          createdCount++;

          if (opCount >= 450) {
            await batch.commit();
            batch = firestore.batch();
            opCount = 0;
          }
        }
        current = current.add(const Duration(days: 1));
      }
    } else {
      // 3. Single instance logic
      final id = _getDeterministicId(date, clientId, timeSlotId);
      final session = Session(
        id: id,
        clientId: clientId,
        timeSlotId: timeSlotId,
        date: Timestamp.fromDate(date),
        status: status,
        services: services,
        isAutoGenerated: isAutoGenerated,
        createdAt: Timestamp.now(),
      );
      batch.set(
        firestore.collection('schedule').doc(id),
        session.toJson(),
        SetOptions(merge: true),
      );
      opCount++;
    }

    if (opCount > 0) {
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider(date));
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> assignCover(
    String clientId,
    String timeSlotId,
    String newEmployeeId,
    String? templateEmployeeId,
    List<ServiceDetail> services,
  ) async {
    final selectedDate = _ref.read(selectedDateProvider);

    if (newEmployeeId == templateEmployeeId) {
      final deterministicId = _getDeterministicId(
        selectedDate,
        clientId,
        timeSlotId,
      );
      await _ref
          .read(sessionRepositoryProvider)
          .deleteSessionException(deterministicId);
      _ref.invalidate(scheduleByDateProvider(selectedDate));
      _ref.invalidate(scheduleViewProvider);
      return;
    }

    final updatedServices = services
        .map(
          (s) => s.copyWith(
            employeeId: newEmployeeId,
            sessionType: SessionType.cover,
          ),
        )
        .toList();

    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: selectedDate,
      endType: RecurrenceEndType.onDate,
    );
  }

  Future<void> bookMakeup(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) {
    final updatedServices = services
        .map((s) => s.copyWith(sessionType: SessionType.makeup))
        .toList();
    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: _ref.read(selectedDateProvider),
      endType: RecurrenceEndType.onDate,
    );
  }

  Future<void> cancelSession(
    String clientId,
    String timeSlotId,
    SessionStatus status,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    status: status,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> completeSession(
    String clientId,
    String timeSlotId,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    status: SessionStatus.completed,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> bookExtraSession(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) {
    final updatedServices = services
        .map((s) => s.copyWith(sessionType: SessionType.extra))
        .toList();
    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: _ref.read(selectedDateProvider),
      endType: RecurrenceEndType.onDate,
    );
  }

  Future<void> updateSessionStatus({
    required String clientId,
    required String timeSlotId,
    required List<ServiceDetail> services,
    required SessionStatus newStatus,
    required DateTime date,
    required String mode,
  }) async {
    final firestore = _ref.read(firestoreProvider);

    if (mode == 'this_only') {
      await bookSession(
        clientId: clientId,
        timeSlotId: timeSlotId,
        status: newStatus,
        services: services,
        date: date,
        endType: RecurrenceEndType.onDate,
      );
    } else {
      var query = firestore
          .collection('schedule')
          .where('clientId', isEqualTo: clientId)
          .where('timeSlotId', isEqualTo: timeSlotId);

      if (mode == 'this_and_following') {
        final startOfDay = DateTime(date.year, date.month, date.day);
        query = query.where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
        );
      }

      final snapshots = await query.get();
      final batch = firestore.batch();
      for (var doc in snapshots.docs) {
        batch.update(doc.reference, {'status': newStatus.name});
      }
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> hardDeleteSession({
    required String clientId,
    required String timeSlotId,
    required DateTime date,
    required String mode,
  }) async {
    final firestore = _ref.read(firestoreProvider);

    if (mode == 'this_only') {
      final id = _getDeterministicId(date, clientId, timeSlotId);
      await _ref.read(sessionRepositoryProvider).deleteSessionException(id);
    } else {
      var query = firestore
          .collection('schedule')
          .where('clientId', isEqualTo: clientId)
          .where('timeSlotId', isEqualTo: timeSlotId);

      if (mode == 'this_and_following') {
        final startOfDay = DateTime(date.year, date.month, date.day);
        query = query.where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
        );
      }

      final snapshots = await query.get();
      final batch = firestore.batch();
      for (var doc in snapshots.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();

      if (mode == 'all' || mode == 'this_and_following') {
        final templateQuery = await firestore
            .collection('schedule_templates')
            .where('clientId', isEqualTo: clientId)
            .limit(1)
            .get();

        if (templateQuery.docs.isNotEmpty) {
          final doc = templateQuery.docs.first;
          final templateData = doc.data();
          final List<dynamic> rulesJson = templateData['rules'] ?? [];

          final List<Map<String, dynamic>> updatedRules = [];
          bool changed = false;

          for (var ruleJson in rulesJson) {
            final ruleMap = ruleJson as Map<String, dynamic>;
            final rule = ScheduleRule.fromJson(ruleMap);

            if (rule.timeSlotId == timeSlotId) {
              changed = true;
              if (mode == 'all') continue;
              final dayBefore = DateTime(
                date.year,
                date.month,
                date.day,
              ).subtract(const Duration(days: 1));
              final updatedRule = ScheduleRule(
                timeSlotId: rule.timeSlotId,
                employeeId: rule.employeeId,
                serviceType: rule.serviceType,
                startTime: rule.startTime,
                endTime: rule.endTime,
                frequency: rule.frequency,
                interval: rule.interval,
                daysOfWeek: rule.daysOfWeek,
                endType: RecurrenceEndType.onDate,
                untilDate: dayBefore,
                dayOfMonth: rule.dayOfMonth,
                startDate: rule.startDate,
              );
              updatedRules.add(updatedRule.toJson());
            } else {
              updatedRules.add(ruleMap);
            }
          }

          if (changed) {
            if (updatedRules.isEmpty) {
              await doc.reference.delete();
            } else {
              await doc.reference.update({
                'rules': updatedRules,
                'updatedAt': Timestamp.now(),
              });
            }
          }
        }
      }
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
    _ref.invalidate(allScheduleTemplatesProvider);
  }

  Future<void> syncTemplatesToInstances(
    DateTime monthDate, {
    String? targetClientId,
  }) async {
    final templates = await _ref.read(allScheduleTemplatesProvider.future);
    final timeSlots = await _ref.read(timeSlotsProvider.future);
    final firestore = _ref.read(firestoreProvider);

    final slotMap = {for (var s in timeSlots) s.id: s};

    final firstDayOfMonth = DateTime(monthDate.year, monthDate.month, 1);
    final lastDayOfMonth = DateTime(monthDate.year, monthDate.month + 1, 0);

    final filteredTemplates = targetClientId != null
        ? templates.where((t) => t.clientId == targetClientId).toList()
        : templates;

    if (filteredTemplates.isEmpty) return;

    var query = firestore
        .collection('schedule')
        .where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(firstDayOfMonth),
        )
        .where('date', isLessThanOrEqualTo: Timestamp.fromDate(lastDayOfMonth));

    if (targetClientId != null) {
      query = query.where('clientId', isEqualTo: targetClientId);
    }

    final existingSessions = await query.get();
    final existingIds = existingSessions.docs.map((doc) => doc.id).toSet();

    final batch = firestore.batch();
    int operationCount = 0;

    for (int day = 1; day <= lastDayOfMonth.day; day++) {
      final date = DateTime(monthDate.year, monthDate.month, day);
      final dayOfWeek = DateFormat('EEEE').format(date);

      for (final template in filteredTemplates) {
        final Map<String, List<ScheduleRule>> rulesBySlotForDay = {};

        for (final rule in template.rules) {
          if (rule.startDate != null) {
            final normalizedStart = DateTime(
              rule.startDate!.year,
              rule.startDate!.month,
              rule.startDate!.day,
            );
            if (date.isBefore(normalizedStart)) continue;
          }
          if (rule.endType == RecurrenceEndType.onDate &&
              rule.untilDate != null) {
            final normalizedUntil = DateTime(
              rule.untilDate!.year,
              rule.untilDate!.month,
              rule.untilDate!.day,
            );
            if (date.isAfter(normalizedUntil)) continue;
          }

          bool matches = false;
          if (rule.frequency == RecurrenceFrequency.daily)
            matches = true;
          else if (rule.frequency == RecurrenceFrequency.weekly &&
              rule.daysOfWeek.contains(dayOfWeek))
            matches = true;
          else if (rule.frequency == RecurrenceFrequency.monthly &&
              rule.dayOfMonth == date.day)
            matches = true;

          if (matches) {
            rulesBySlotForDay.putIfAbsent(rule.timeSlotId, () => []).add(rule);
          }
        }

        for (final slotId in rulesBySlotForDay.keys) {
          final id = _getDeterministicId(date, template.clientId, slotId);
          if (existingIds.contains(id)) continue;

          final docRef = firestore.collection('schedule').doc(id);
          final slot = slotMap[slotId];
          final rules = rulesBySlotForDay[slotId]!;

          final session = Session(
            id: id,
            clientId: template.clientId,
            timeSlotId: slotId,
            date: Timestamp.fromDate(date),
            status: SessionStatus.scheduled,
            services: rules
                .map(
                  (r) => ServiceDetail(
                    type: r.serviceType,
                    sessionType: SessionType.regular,
                    employeeId: r.employeeId,
                    startTime: r.startTime.isNotEmpty
                        ? r.startTime
                        : (slot?.startTime ?? ''),
                    endTime: r.endTime.isNotEmpty
                        ? r.endTime
                        : (slot?.endTime ?? ''),
                  ),
                )
                .toList(),
            isAutoGenerated: true,
            createdAt: Timestamp.now(),
          );

          batch.set(docRef, session.toJson());
          operationCount++;
          if (operationCount >= 450) {
            await batch.commit();
            operationCount = 0;
          }
        }
      }
    }

    if (operationCount > 0) {
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }
}
