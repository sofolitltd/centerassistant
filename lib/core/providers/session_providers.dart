import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/models/schedule_template.dart';
import '/core/models/session.dart';
import '/core/providers/client_providers.dart';
import '/core/providers/employee_providers.dart';
import '/core/providers/leave_providers.dart';
import '/core/providers/schedule_template_providers.dart';
import '/core/providers/time_slot_providers.dart';
import '/services/firebase_service.dart';
import '../data/repositories/session_repository_impl.dart';
import '../domain/repositories/session_repository.dart';

class SelectedDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  void setDate(DateTime newDate) {
    state = DateTime(newDate.year, newDate.month, newDate.day);
  }
}

final selectedDateProvider = NotifierProvider<SelectedDateNotifier, DateTime>(
  () {
    return SelectedDateNotifier();
  },
);

class ScheduleFilter {
  final String? clientId;
  final String? employeeId;

  const ScheduleFilter({this.clientId, this.employeeId});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScheduleFilter &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          employeeId == other.employeeId;

  @override
  int get hashCode => clientId.hashCode ^ employeeId.hashCode;
}

class ScheduleFilterNotifier extends Notifier<ScheduleFilter> {
  @override
  ScheduleFilter build() => const ScheduleFilter();

  void setFilter(ScheduleFilter filter) => state = filter;
  void clear() => state = const ScheduleFilter();
}

final scheduleFilterProvider =
    NotifierProvider<ScheduleFilterNotifier, ScheduleFilter>(
      ScheduleFilterNotifier.new,
    );

final sessionRepositoryProvider = Provider<ISessionRepository>((ref) {
  return SessionRepositoryImpl(ref.watch(firestoreProvider));
});

class ScheduleView {
  final List<dynamic> timeSlots;
  final Map<String, List<SessionCardData>> sessionsByTimeSlot;

  ScheduleView({required this.timeSlots, required this.sessionsByTimeSlot});
}

class SessionCardData {
  final String? sessionId;
  final String clientDocId; // Document ID
  final String clientId; // Sequential ID (e.g., 1)
  final String clientName;
  final String? clientNickName;
  final SessionType sessionType;
  final List<ServiceDetail> services;
  final String? notes;
  final String? templateEmployeeId;
  final bool isAutoGenerated;
  final Map<String, String> employeeNames; // employeeId -> name/nickName

  SessionCardData({
    this.sessionId,
    required this.clientDocId,
    required this.clientId,
    required this.clientName,
    this.clientNickName,
    required this.sessionType,
    required this.services,
    this.notes,
    this.templateEmployeeId,
    this.isAutoGenerated = false,
    this.employeeNames = const {},
  });

  /// Used for Weekly/Monthly views: Nickname(ID)
  String get displayNickName =>
      '${(clientNickName != null && clientNickName!.isNotEmpty) ? clientNickName : clientName}($clientId)';

  /// Used for Daily view: FullName(ID)
  String get displayFullName => '$clientName($clientId)';

  double get totalDuration =>
      services.fold(0.0, (sum, item) => sum + item.duration);

  String get servicesDisplay =>
      '[${services.map((s) => s.toString()).join(', ')}]';

  // Helpers for DailyView
  String get serviceNames => services.map((s) => s.type).join('\n');
  String get therapists => services.map((s) {
    final name = employeeNames[s.employeeId];
    return name ?? '-';
  }).join('\n');
  String get hours => services.map((s) => '${s.startTime}-${s.endTime}').join('\n');
  String get durations => services.map((s) => '${s.duration.toStringAsFixed(1)}h').join('\n');
  String get inclusiveStatus => services.map((s) => s.isInclusive ? 'Inc' : 'Exc').join('\n');
  
  String get status => sessionType.name;
  String get id => sessionId ?? '';
}

final scheduleByDateProvider = FutureProvider.autoDispose
    .family<ScheduleView, DateTime>((ref, date) async {
      final filter = ref.watch(scheduleFilterProvider);
      final timeSlots = await ref.watch(timeSlotsProvider.future);
      final clients = await ref.watch(clientsProvider.future);
      final employees = await ref.watch(employeesProvider.future);
      final templates = await ref.watch(allScheduleTemplatesProvider.future);
      final sessions = await ref
          .watch(sessionRepositoryProvider)
          .getSessionsByDate(date);
      final leaves = await ref.watch(leavesByDateProvider(date).future);

      final clientMap = {for (var c in clients) c.id: c};
      final employeeMap = {for (var t in employees) t.id: t};
      final slotMap = {for (var s in timeSlots) s.id: s};

      final dayLeaves = {for (var l in leaves) l.employeeId: l};

      final dayOfWeek = DateFormat('EEEE').format(date);
      final sessionsByTimeSlot = <String, List<SessionCardData>>{};

      final templateEmployeeMap = <String, Map<String, String>>{};

      final normalizedDate = DateTime(date.year, date.month, date.day);

      String getDeterministicId(DateTime d, String cId, String tId) {
        final dateStr = DateFormat('yyyy-MM-dd').format(d);
        return '${dateStr}_${cId}_$tId';
      }

      for (final template in templates) {
        if (filter.clientId != null && template.clientId != filter.clientId) {
          continue;
        }

        for (final rule in template.rules) {
          if (filter.employeeId != null &&
              rule.employeeId != filter.employeeId) {
            continue;
          }

          // Robust Start Date Check
          if (rule.startDate != null) {
            final normalizedStart = DateTime(
              rule.startDate!.year,
              rule.startDate!.month,
              rule.startDate!.day,
            );
            if (normalizedDate.isBefore(normalizedStart)) continue;
          }

          // Robust End Date Check
          if (rule.endType == RecurrenceEndType.onDate &&
              rule.untilDate != null) {
            final normalizedUntil = DateTime(
              rule.untilDate!.year,
              rule.untilDate!.month,
              rule.untilDate!.day,
            );
            if (normalizedDate.isAfter(normalizedUntil)) continue;
          }

          bool isMatch = false;
          if (rule.frequency == RecurrenceFrequency.daily) {
            isMatch = true;
          } else if (rule.frequency == RecurrenceFrequency.weekly &&
              rule.daysOfWeek.contains(dayOfWeek)) {
            isMatch = true;
          } else if (rule.frequency == RecurrenceFrequency.monthly &&
              rule.dayOfMonth == date.day) {
            isMatch = true;
          }

          if (isMatch) {
            final client = clientMap[template.clientId];
            final employee = employeeMap[rule.employeeId];
            final slot = slotMap[rule.timeSlotId];

            if (client != null && employee != null) {
              templateEmployeeMap.putIfAbsent(
                rule.timeSlotId,
                () => {},
              )[client.id] = employee.id;

              final bool isEmployeeOnLeave = dayLeaves.containsKey(employee.id);
              final bool isClientOnLeave = dayLeaves.containsKey(client.id);

              final service = ServiceDetail(
                type: rule.serviceType,
                employeeId: employee.id,
                startTime: rule.startTime.isNotEmpty
                    ? rule.startTime
                    : (slot?.startTime ?? ''),
                endTime: rule.endTime.isNotEmpty
                    ? rule.endTime
                    : (slot?.endTime ?? ''),
                isInclusive: false, // Defaulting to false, should ideally come from rule if available
              );

              final list = sessionsByTimeSlot.putIfAbsent(rule.timeSlotId, () => []);
              final existingIndex = list.indexWhere((s) => s.clientDocId == client.id);

              if (existingIndex != -1) {
                final existing = list[existingIndex];
                list[existingIndex] = SessionCardData(
                  sessionId: existing.sessionId,
                  clientDocId: existing.clientDocId,
                  clientId: existing.clientId,
                  clientName: existing.clientName,
                  clientNickName: existing.clientNickName,
                  sessionType: existing.sessionType,
                  services: [...existing.services, service],
                  templateEmployeeId: existing.templateEmployeeId,
                  isAutoGenerated: existing.isAutoGenerated,
                  employeeNames: {
                    ...existing.employeeNames,
                    employee.id: employee.nickName.isNotEmpty ? employee.nickName : employee.name,
                  },
                );
              } else {
                list.add(
                  SessionCardData(
                    sessionId: getDeterministicId(date, client.id, rule.timeSlotId),
                    clientDocId: client.id,
                    clientId: client.clientId,
                    clientNickName: client.nickName,
                    clientName: client.name,
                    sessionType: (isEmployeeOnLeave || isClientOnLeave)
                        ? SessionType.cancelled
                        : SessionType.regular,
                    services: [service],
                    templateEmployeeId: employee.id,
                    isAutoGenerated: true,
                    employeeNames: {
                      employee.id: employee.nickName.isNotEmpty ? employee.nickName : employee.name,
                    },
                    notes: isEmployeeOnLeave
                        ? 'Employee on leave'
                        : (isClientOnLeave ? 'Client on leave' : null),
                  ),
                );
              }
            }
          }
        }
      }

      for (final exception in sessions) {
        if (filter.clientId != null && exception.clientId != filter.clientId) {
          continue;
        }

        if (filter.employeeId != null &&
            !exception.services.any((s) => s.employeeId == filter.employeeId)) {
          continue;
        }

        final client = clientMap[exception.clientId];

        if (client != null) {
          final tId = templateEmployeeMap[exception.timeSlotId]?[client.id];

          final names = <String, String>{};
          for (final s in exception.services) {
            final emp = employeeMap[s.employeeId];
            if (emp != null) {
              names[s.employeeId] = emp.nickName.isNotEmpty ? emp.nickName : emp.name;
            }
          }

          final card = SessionCardData(
            sessionId: exception.id,
            clientDocId: client.id,
            clientId: client.clientId,
            clientNickName: client.nickName,
            clientName: client.name,
            sessionType: exception.sessionType,
            services: exception.services,
            notes: exception.notes,
            templateEmployeeId: tId,
            isAutoGenerated: exception.isAutoGenerated,
            employeeNames: names,
          );

          if (sessionsByTimeSlot.containsKey(exception.timeSlotId)) {
            final index = sessionsByTimeSlot[exception.timeSlotId]!.indexWhere(
              (s) => s.clientDocId == exception.clientId,
            );
            if (index != -1) {
              sessionsByTimeSlot[exception.timeSlotId]![index] = card;
            } else {
              sessionsByTimeSlot
                  .putIfAbsent(exception.timeSlotId, () => [])
                  .add(card);
            }
          } else {
            sessionsByTimeSlot
                .putIfAbsent(exception.timeSlotId, () => [])
                .add(card);
          }
        }
      }
      return ScheduleView(
        timeSlots: timeSlots,
        sessionsByTimeSlot: sessionsByTimeSlot,
      );
    });

final scheduleViewProvider = FutureProvider.autoDispose<ScheduleView>((
  ref,
) async {
  final selectedDate = ref.watch(selectedDateProvider);
  return ref.watch(scheduleByDateProvider(selectedDate).future);
});

final sessionServiceProvider = Provider((ref) => SessionActionService(ref));

class SessionActionService {
  final Ref _ref;
  SessionActionService(this._ref);

  String _getDeterministicId(
    DateTime date,
    String clientId,
    String timeSlotId,
  ) {
    final dateStr = DateFormat('yyyy-MM-dd').format(date);
    return '${dateStr}_${clientId}_$timeSlotId';
  }

  Future<void> bookSession({
    required String clientId,
    required String timeSlotId,
    required SessionType sessionType,
    required List<ServiceDetail> services,
    required DateTime date,
    bool isAutoGenerated = false,
    bool isRecurring = false,
    RecurrenceFrequency frequency = RecurrenceFrequency.none,
    int interval = 1,
    List<String> daysOfWeek = const [],
    required RecurrenceEndType endType,
    DateTime? untilDate,
    int? occurrences,
  }) async {
    final id = _getDeterministicId(date, clientId, timeSlotId);

    final session = Session(
      id: id,
      clientId: clientId,
      timeSlotId: timeSlotId,
      date: Timestamp.fromDate(date),
      sessionType: sessionType,
      services: services,
      isAutoGenerated: isAutoGenerated,
      createdAt: Timestamp.now(),
    );

    // 1. Create the session instance for the selected date
    await _ref.read(sessionRepositoryProvider).createSessionException(session);

    // 2. If recurring, create the template rule
    if (isRecurring && frequency != RecurrenceFrequency.none) {
      for (final service in services) {
        await _ref
            .read(scheduleTemplateServiceProvider)
            .setScheduleRule(
              clientId: clientId,
              timeSlotId: timeSlotId,
              employeeId: service.employeeId,
              serviceType: service.type,
              startTime: service.startTime,
              endTime: service.endTime,
              frequency: frequency,
              interval: interval,
              daysOfWeek: daysOfWeek,
              endType: endType,
              untilDate: untilDate,
              occurrences: occurrences,
              dayOfMonth: frequency == RecurrenceFrequency.monthly
                  ? date.day
                  : null,
              startDate: date,
            );
      }

      // 3. Trigger background sync without awaiting to avoid UI blocking
      _syncInBackground(date);
    }

    _ref.invalidate(scheduleByDateProvider(date));
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> _syncInBackground(DateTime date) async {
    try {
      await syncTemplatesToInstances(date);
      await syncTemplatesToInstances(DateTime(date.year, date.month + 1, 1));
    } catch (e) {
      // Background error handled silently or logged
    }
  }

  Future<void> assignCover(
    String clientId,
    String timeSlotId,
    String newEmployeeId,
    String? templateEmployeeId,
    List<ServiceDetail> services,
  ) async {
    final selectedDate = _ref.read(selectedDateProvider);

    if (newEmployeeId == templateEmployeeId) {
      final deterministicId = _getDeterministicId(
        selectedDate,
        clientId,
        timeSlotId,
      );
      await _ref
          .read(sessionRepositoryProvider)
          .deleteSessionException(deterministicId);
      _ref.invalidate(scheduleByDateProvider(selectedDate));
      _ref.invalidate(scheduleViewProvider);
      return;
    }

    final updatedServices = services
        .map((s) => s.copyWith(employeeId: newEmployeeId))
        .toList();

    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      sessionType: SessionType.cover,
      services: updatedServices,
      date: selectedDate,
      endType: RecurrenceEndType.onDate, // Default for non-recurring
    );
  }

  Future<void> bookMakeup(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    sessionType: SessionType.makeup,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> cancelSession(
    String clientId,
    String timeSlotId,
    SessionType type,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    sessionType: type,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> completeSession(
    String clientId,
    String timeSlotId,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    sessionType: SessionType.completed,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> bookExtraSession(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    sessionType: SessionType.extra,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> syncTemplatesToInstances(DateTime monthDate) async {
    final templates = await _ref.read(allScheduleTemplatesProvider.future);
    final timeSlots = await _ref.read(timeSlotsProvider.future);
    final firestore = _ref.read(firestoreProvider);

    final slotMap = {for (var s in timeSlots) s.id: s};

    final firstDayOfMonth = DateTime(monthDate.year, monthDate.month, 1);
    final lastDayOfMonth = DateTime(monthDate.year, monthDate.month + 1, 0);

    final existingSessions = await firestore
        .collection('schedule')
        .where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(firstDayOfMonth),
        )
        .where('date', isLessThanOrEqualTo: Timestamp.fromDate(lastDayOfMonth))
        .get();

    final existingIds = existingSessions.docs.map((doc) => doc.id).toSet();
    final batch = firestore.batch();
    int operationCount = 0;

    for (int day = 1; day <= lastDayOfMonth.day; day++) {
      final date = DateTime(monthDate.year, monthDate.month, day);
      final dayOfWeek = DateFormat('EEEE').format(date);

      for (final template in templates) {
        for (final rule in template.rules) {
          // Robust Start Date Check
          if (rule.startDate != null) {
            final normalizedStart = DateTime(
              rule.startDate!.year,
              rule.startDate!.month,
              rule.startDate!.day,
            );
            if (date.isBefore(normalizedStart)) continue;
          }

          // Robust End Date Check
          if (rule.endType == RecurrenceEndType.onDate &&
              rule.untilDate != null) {
            final normalizedUntil = DateTime(
              rule.untilDate!.year,
              rule.untilDate!.month,
              rule.untilDate!.day,
            );
            if (date.isAfter(normalizedUntil)) continue;
          }

          bool shouldCreate = false;
          if (rule.frequency == RecurrenceFrequency.daily) {
            shouldCreate = true;
          } else if (rule.frequency == RecurrenceFrequency.weekly &&
              rule.daysOfWeek.contains(dayOfWeek)) {
            shouldCreate = true;
          } else if (rule.frequency == RecurrenceFrequency.monthly &&
              rule.dayOfMonth == date.day) {
            shouldCreate = true;
          }

          if (shouldCreate) {
            final id = _getDeterministicId(
              date,
              template.clientId,
              rule.timeSlotId,
            );

            if (existingIds.contains(id)) continue;

            final docRef = firestore.collection('schedule').doc(id);
            final slot = slotMap[rule.timeSlotId];

            final session = Session(
              id: id,
              clientId: template.clientId,
              timeSlotId: rule.timeSlotId,
              date: Timestamp.fromDate(date),
              sessionType: SessionType.regular,
              services: [
                ServiceDetail(
                  type: rule.serviceType,
                  employeeId: rule.employeeId,
                  startTime: rule.startTime.isNotEmpty
                      ? rule.startTime
                      : (slot?.startTime ?? ''),
                  endTime: rule.endTime.isNotEmpty
                      ? rule.endTime
                      : (slot?.endTime ?? ''),
                ),
              ],
              isAutoGenerated: true,
              createdAt: Timestamp.now(),
            );

            batch.set(docRef, session.toJson(), SetOptions(merge: true));
            operationCount++;

            if (operationCount >= 450) {
              await batch.commit();
              operationCount = 0;
            }
          }
        }
      }
    }

    if (operationCount > 0) {
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }
}
