import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/models/schedule_template.dart';
import '/core/models/session.dart';
import '/core/providers/client_providers.dart';
import '/core/providers/employee_providers.dart';
import '/core/providers/schedule_template_providers.dart';
import '/core/providers/time_slot_providers.dart';
import '/services/firebase_service.dart';
import '../data/repositories/session_repository_impl.dart';
import '../domain/repositories/session_repository.dart';

class SelectedDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  void setDate(DateTime newDate) {
    state = DateTime(newDate.year, newDate.month, newDate.day);
  }
}

final selectedDateProvider = NotifierProvider<SelectedDateNotifier, DateTime>(
  () {
    return SelectedDateNotifier();
  },
);

class ScheduleFilter {
  final String? clientId;
  final String? employeeId;

  const ScheduleFilter({this.clientId, this.employeeId});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScheduleFilter &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          employeeId == other.employeeId;

  @override
  int get hashCode => clientId.hashCode ^ employeeId.hashCode;
}

class ScheduleFilterNotifier extends Notifier<ScheduleFilter> {
  @override
  ScheduleFilter build() => const ScheduleFilter();

  void setFilter(ScheduleFilter filter) => state = filter;
  void clear() => state = const ScheduleFilter();
}

final scheduleFilterProvider =
    NotifierProvider<ScheduleFilterNotifier, ScheduleFilter>(
      ScheduleFilterNotifier.new,
    );

final sessionRepositoryProvider = Provider<ISessionRepository>((ref) {
  return SessionRepositoryImpl(ref.watch(firestoreProvider));
});

class ScheduleView {
  final List<dynamic> timeSlots;
  final Map<String, List<SessionCardData>> sessionsByTimeSlot;

  ScheduleView({required this.timeSlots, required this.sessionsByTimeSlot});
}

class SessionCardData {
  final String? sessionId;
  final String clientDocId; // Document ID
  final String clientId; // Sequential ID (e.g., 1)
  final String clientName;
  final String? clientNickName;
  final SessionStatus status;
  final List<ServiceDetail> services;
  final String? notes;
  final String? templateEmployeeId;
  final bool isAutoGenerated;
  final Map<String, String> employeeNames; // employeeId -> name/nickName

  SessionCardData({
    this.sessionId,
    required this.clientDocId,
    required this.clientId,
    required this.clientName,
    this.clientNickName,
    required this.status,
    required this.services,
    this.notes,
    this.templateEmployeeId,
    this.isAutoGenerated = false,
    this.employeeNames = const {},
  });

  /// Used for Weekly/Monthly views: Nickname(ID)
  String get displayNickName =>
      '${(clientNickName != null && clientNickName!.isNotEmpty) ? clientNickName : clientName}($clientId)';

  /// Used for Daily view: FullName(ID)
  String get displayFullName => '$clientName($clientId)';

  double get totalDuration =>
      services.fold(0.0, (sum, item) => sum + item.duration);

  String get servicesDisplay =>
      '[${services.map((s) => s.toString()).join(', ')}]';

  // Helpers for DailyView
  String get serviceNames => services.map((s) => s.type).join('\n');
  String get therapists => services
      .map((s) {
        final name = employeeNames[s.employeeId];
        return name ?? '-';
      })
      .join('\n');
  String get hours =>
      services.map((s) => '${s.startTime}-${s.endTime}').join('\n');
  String get durations =>
      services.map((s) => '${s.duration.toStringAsFixed(1)}h').join('\n');
  String get inclusiveStatus =>
      services.map((s) => s.isInclusive ? 'Inclusive' : 'Exclusive').join('\n');
  String get typeDisplay =>
      services.map((s) => s.sessionType.displayName).toSet().join('\n');

  String get id => sessionId ?? '';
}

final scheduleByDateProvider = FutureProvider.autoDispose
    .family<ScheduleView, DateTime>((ref, date) async {
      final filter = ref.watch(scheduleFilterProvider);
      final timeSlots = await ref.watch(timeSlotsProvider.future);
      final clients = await ref.watch(clientsProvider.future);
      final employees = await ref.watch(employeesProvider.future);

      // We only show real instances from the schedule collection
      final sessions = await ref
          .watch(sessionRepositoryProvider)
          .getSessionsByDate(date);

      final clientMap = {for (var c in clients) c.id: c};
      final employeeMap = {for (var t in employees) t.id: t};

      final sessionsByTimeSlot = <String, List<SessionCardData>>{};

      for (final session in sessions) {
        if (filter.clientId != null && session.clientId != filter.clientId) {
          continue;
        }

        if (filter.employeeId != null &&
            !session.services.any((s) => s.employeeId == filter.employeeId)) {
          continue;
        }

        final client = clientMap[session.clientId];

        if (client != null) {
          final names = <String, String>{};
          for (final s in session.services) {
            final emp = employeeMap[s.employeeId];
            if (emp != null) {
              names[s.employeeId] = emp.nickName.isNotEmpty
                  ? emp.nickName
                  : emp.name;
            }
          }

          final card = SessionCardData(
            sessionId: session.id,
            clientDocId: client.id,
            clientId: client.clientId,
            clientNickName: client.nickName,
            clientName: client.name,
            status: session.status,
            services: session.services,
            notes: session.notes,
            isAutoGenerated: session.isAutoGenerated,
            employeeNames: names,
          );

          sessionsByTimeSlot
              .putIfAbsent(session.timeSlotId, () => [])
              .add(card);
        }
      }
      return ScheduleView(
        timeSlots: timeSlots,
        sessionsByTimeSlot: sessionsByTimeSlot,
      );
    });

final scheduleViewProvider = FutureProvider.autoDispose<ScheduleView>((
  ref,
) async {
  final selectedDate = ref.watch(selectedDateProvider);
  return ref.watch(scheduleByDateProvider(selectedDate).future);
});

final sessionServiceProvider = Provider((ref) => SessionActionService(ref));

class SessionActionService {
  final Ref _ref;
  SessionActionService(this._ref);

  String _getDeterministicId(
    DateTime date,
    String clientId,
    String timeSlotId,
  ) {
    final dateStr = DateFormat('yyyy-MM-dd').format(date);
    return '${dateStr}_${clientId}_$timeSlotId';
  }

  Future<void> bookSession({
    required String clientId,
    required String timeSlotId,
    required SessionStatus status,
    required List<ServiceDetail> services,
    required DateTime date,
    bool isAutoGenerated = false,
    bool isRecurring = false,
    RecurrenceFrequency frequency = RecurrenceFrequency.none,
    int interval = 1,
    List<String> daysOfWeek = const [],
    required RecurrenceEndType endType,
    DateTime? untilDate,
    int? occurrences,
  }) async {
    final id = _getDeterministicId(date, clientId, timeSlotId);

    final session = Session(
      id: id,
      clientId: clientId,
      timeSlotId: timeSlotId,
      date: Timestamp.fromDate(date),
      status: status,
      services: services,
      isAutoGenerated: isAutoGenerated,
      createdAt: Timestamp.now(),
    );

    // 1. Create the session instance for the selected date
    await _ref.read(sessionRepositoryProvider).createSessionException(session);

    // 2. If recurring, create the template rule
    if (isRecurring && frequency != RecurrenceFrequency.none) {
      for (final service in services) {
        await _ref
            .read(scheduleTemplateServiceProvider)
            .setScheduleRule(
              clientId: clientId,
              timeSlotId: timeSlotId,
              employeeId: service.employeeId,
              serviceType: service.type,
              startTime: service.startTime,
              endTime: service.endTime,
              frequency: frequency,
              interval: interval,
              daysOfWeek: daysOfWeek,
              endType: endType,
              untilDate: untilDate,
              occurrences: occurrences,
              dayOfMonth: frequency == RecurrenceFrequency.monthly
                  ? date.day
                  : null,
              startDate: date,
            );
      }

      // 3. Trigger background sync without awaiting to avoid UI blocking
      _syncInBackground(date);
    }

    _ref.invalidate(scheduleByDateProvider(date));
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> _syncInBackground(DateTime date) async {
    try {
      await syncTemplatesToInstances(date);
      await syncTemplatesToInstances(DateTime(date.year, date.month + 1, 1));
    } catch (e) {
      // Background error handled silently or logged
    }
  }

  Future<void> assignCover(
    String clientId,
    String timeSlotId,
    String newEmployeeId,
    String? templateEmployeeId,
    List<ServiceDetail> services,
  ) async {
    final selectedDate = _ref.read(selectedDateProvider);

    if (newEmployeeId == templateEmployeeId) {
      final deterministicId = _getDeterministicId(
        selectedDate,
        clientId,
        timeSlotId,
      );
      await _ref
          .read(sessionRepositoryProvider)
          .deleteSessionException(deterministicId);
      _ref.invalidate(scheduleByDateProvider(selectedDate));
      _ref.invalidate(scheduleViewProvider);
      return;
    }

    final updatedServices = services
        .map(
          (s) => s.copyWith(
            employeeId: newEmployeeId,
            sessionType: SessionType.cover,
          ),
        )
        .toList();

    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: selectedDate,
      endType: RecurrenceEndType.onDate, // Default for non-recurring
    );
  }

  Future<void> bookMakeup(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) {
    final updatedServices = services
        .map((s) => s.copyWith(sessionType: SessionType.makeup))
        .toList();
    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: _ref.read(selectedDateProvider),
      endType: RecurrenceEndType.onDate,
    );
  }

  Future<void> cancelSession(
    String clientId,
    String timeSlotId,
    SessionStatus status,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    status: status,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> completeSession(
    String clientId,
    String timeSlotId,
    List<ServiceDetail> services,
  ) => bookSession(
    clientId: clientId,
    timeSlotId: timeSlotId,
    status: SessionStatus.completed,
    services: services,
    date: _ref.read(selectedDateProvider),
    endType: RecurrenceEndType.onDate,
  );

  Future<void> bookExtraSession(
    String clientId,
    String timeSlotId,
    String employeeId,
    List<ServiceDetail> services,
  ) {
    final updatedServices = services
        .map((s) => s.copyWith(sessionType: SessionType.extra))
        .toList();
    return bookSession(
      clientId: clientId,
      timeSlotId: timeSlotId,
      status: SessionStatus.scheduled,
      services: updatedServices,
      date: _ref.read(selectedDateProvider),
      endType: RecurrenceEndType.onDate,
    );
  }

  Future<void> updateSessionStatus({
    required String clientId,
    required String timeSlotId,
    required List<ServiceDetail> services,
    required SessionStatus newStatus,
    required DateTime date,
    required String mode, // 'this_only', 'this_and_following', 'all'
  }) async {
    final firestore = _ref.read(firestoreProvider);

    if (mode == 'this_only') {
      await bookSession(
        clientId: clientId,
        timeSlotId: timeSlotId,
        status: newStatus,
        services: services,
        date: date,
        endType: RecurrenceEndType.onDate,
      );
    } else {
      // mode is 'this_and_following' or 'all'
      var query = firestore
          .collection('schedule')
          .where('clientId', isEqualTo: clientId)
          .where('timeSlotId', isEqualTo: timeSlotId);

      if (mode == 'this_and_following') {
        final startOfDay = DateTime(date.year, date.month, date.day);
        query = query.where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
        );
      }

      try {
        final snapshots = await query.get();
        print(
          'Updating ${snapshots.docs.length} sessions for clientId: $clientId, timeSlotId: $timeSlotId, mode: $mode',
        );
        final batch = firestore.batch();
        for (var doc in snapshots.docs) {
          batch.update(doc.reference, {'status': newStatus.name});
        }
        await batch.commit();
      } catch (e) {
        print('Error in updateSessionStatus query: $e');
        // If it's an index error, the error message from Firebase will contain the link.
        rethrow;
      }
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> softDeleteSession({
    required String clientId,
    required String timeSlotId,
    required List<ServiceDetail> services,
    required DateTime date,
    required String mode, // 'this_only', 'this_and_following', 'all'
  }) async {
    final firestore = _ref.read(firestoreProvider);

    if (mode == 'this_only') {
      await bookSession(
        clientId: clientId,
        timeSlotId: timeSlotId,
        status: SessionStatus.cancelledCenter,
        services: services,
        date: date,
        endType: RecurrenceEndType.onDate,
      );
    } else {
      var query = firestore
          .collection('schedule')
          .where('clientId', isEqualTo: clientId)
          .where('timeSlotId', isEqualTo: timeSlotId);

      if (mode == 'this_and_following') {
        final startOfDay = DateTime(date.year, date.month, date.day);
        query = query.where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
        );
      }

      final snapshots = await query.get();
      final batch = firestore.batch();
      for (var doc in snapshots.docs) {
        batch.update(doc.reference, {
          'status': SessionStatus.cancelledCenter.name,
        });
      }
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }

  Future<void> hardDeleteSession({
    required String clientId,
    required String timeSlotId,
    required DateTime date,
    required String mode, // 'this_only', 'this_and_following', 'all'
  }) async {
    final firestore = _ref.read(firestoreProvider);

    if (mode == 'this_only') {
      final id = _getDeterministicId(date, clientId, timeSlotId);
      await _ref.read(sessionRepositoryProvider).deleteSessionException(id);
    } else {
      // 1. Clean up schedule instances in Firestore
      var query = firestore
          .collection('schedule')
          .where('clientId', isEqualTo: clientId)
          .where('timeSlotId', isEqualTo: timeSlotId);

      if (mode == 'this_and_following') {
        final startOfDay = DateTime(date.year, date.month, date.day);
        query = query.where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay),
        );
      }

      final snapshots = await query.get();
      final batch = firestore.batch();
      for (var doc in snapshots.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();

      // 2. Update/Delete from Schedule Templates
      if (mode == 'all' || mode == 'this_and_following') {
        final templateQuery = await firestore
            .collection('schedule_templates')
            .where('clientId', isEqualTo: clientId)
            .limit(1)
            .get();

        if (templateQuery.docs.isNotEmpty) {
          final doc = templateQuery.docs.first;
          final templateData = doc.data();
          final List<dynamic> rulesJson = templateData['rules'] ?? [];

          final List<Map<String, dynamic>> updatedRules = [];
          bool changed = false;

          for (var ruleJson in rulesJson) {
            final ruleMap = ruleJson as Map<String, dynamic>;
            final rule = ScheduleRule.fromJson(ruleMap);

            if (rule.timeSlotId == timeSlotId) {
              changed = true;
              if (mode == 'all') {
                // Remove rule entirely
                continue;
              } else {
                // mode == 'this_and_following'
                // End the rule on the day before the selected date
                final dayBefore = DateTime(
                  date.year,
                  date.month,
                  date.day,
                ).subtract(const Duration(days: 1));

                final updatedRule = ScheduleRule(
                  timeSlotId: rule.timeSlotId,
                  employeeId: rule.employeeId,
                  serviceType: rule.serviceType,
                  startTime: rule.startTime,
                  endTime: rule.endTime,
                  frequency: rule.frequency,
                  interval: rule.interval,
                  daysOfWeek: rule.daysOfWeek,
                  endType: RecurrenceEndType.onDate,
                  untilDate: dayBefore,
                  dayOfMonth: rule.dayOfMonth,
                  startDate: rule.startDate,
                );
                updatedRules.add(updatedRule.toJson());
              }
            } else {
              updatedRules.add(ruleMap);
            }
          }

          if (changed) {
            await doc.reference.update({
              'rules': updatedRules,
              'updatedAt': Timestamp.now(),
            });
          }
        }
      }
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
    _ref.invalidate(allScheduleTemplatesProvider);
  }

  Future<void> syncTemplatesToInstances(DateTime monthDate) async {
    final templates = await _ref.read(allScheduleTemplatesProvider.future);
    final timeSlots = await _ref.read(timeSlotsProvider.future);
    final firestore = _ref.read(firestoreProvider);

    final slotMap = {for (var s in timeSlots) s.id: s};

    final firstDayOfMonth = DateTime(monthDate.year, monthDate.month, 1);
    final lastDayOfMonth = DateTime(monthDate.year, monthDate.month + 1, 0);

    final existingSessions = await firestore
        .collection('schedule')
        .where(
          'date',
          isGreaterThanOrEqualTo: Timestamp.fromDate(firstDayOfMonth),
        )
        .where('date', isLessThanOrEqualTo: Timestamp.fromDate(lastDayOfMonth))
        .get();

    final existingIds = existingSessions.docs.map((doc) => doc.id).toSet();
    final batch = firestore.batch();
    int operationCount = 0;

    for (int day = 1; day <= lastDayOfMonth.day; day++) {
      final date = DateTime(monthDate.year, monthDate.month, day);
      final dayOfWeek = DateFormat('EEEE').format(date);

      for (final template in templates) {
        for (final rule in template.rules) {
          // Robust Start Date Check
          if (rule.startDate != null) {
            final normalizedStart = DateTime(
              rule.startDate!.year,
              rule.startDate!.month,
              rule.startDate!.day,
            );
            if (date.isBefore(normalizedStart)) continue;
          }

          // Robust End Date Check
          if (rule.endType == RecurrenceEndType.onDate &&
              rule.untilDate != null) {
            final normalizedUntil = DateTime(
              rule.untilDate!.year,
              rule.untilDate!.month,
              rule.untilDate!.day,
            );
            if (date.isAfter(normalizedUntil)) continue;
          }

          bool shouldCreate = false;
          if (rule.frequency == RecurrenceFrequency.daily) {
            shouldCreate = true;
          } else if (rule.frequency == RecurrenceFrequency.weekly &&
              rule.daysOfWeek.contains(dayOfWeek)) {
            shouldCreate = true;
          } else if (rule.frequency == RecurrenceFrequency.monthly &&
              rule.dayOfMonth == date.day) {
            shouldCreate = true;
          }

          if (shouldCreate) {
            final id = _getDeterministicId(
              date,
              template.clientId,
              rule.timeSlotId,
            );

            if (existingIds.contains(id)) continue;

            final docRef = firestore.collection('schedule').doc(id);
            final slot = slotMap[rule.timeSlotId];

            final session = Session(
              id: id,
              clientId: template.clientId,
              timeSlotId: rule.timeSlotId,
              date: Timestamp.fromDate(date),
              status: SessionStatus.scheduled,
              services: [
                ServiceDetail(
                  type: rule.serviceType,
                  sessionType: SessionType.regular,
                  employeeId: rule.employeeId,
                  startTime: rule.startTime.isNotEmpty
                      ? rule.startTime
                      : (slot?.startTime ?? ''),
                  endTime: rule.endTime.isNotEmpty
                      ? rule.endTime
                      : (slot?.endTime ?? ''),
                ),
              ],
              isAutoGenerated: true,
              createdAt: Timestamp.now(),
            );

            batch.set(docRef, session.toJson(), SetOptions(merge: true));
            operationCount++;

            if (operationCount >= 450) {
              await batch.commit();
              operationCount = 0;
            }
          }
        }
      }
    }

    if (operationCount > 0) {
      await batch.commit();
    }

    _ref.invalidate(scheduleByDateProvider);
    _ref.invalidate(scheduleViewProvider);
  }
}
